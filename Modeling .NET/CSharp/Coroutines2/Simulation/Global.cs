using System;
using System.Collections.Generic;
using System.Text;
using System.Threading;

namespace Simulation
{
    /// <summary>
    /// Класс Global содержит основные глобальные переменные и методы, управляющие процессом имитации.
    /// Выполняет переключение потоков в режиме сопрограмм.
    /// </summary>
    public class Global
    {
        /// <summary>
        /// Периодичность срабатывания очистки завершенных объектов
        /// </summary>
        static public double CleanTimeStep = 1;

        /// <summary>
        /// Ссылка на текущую исполняемую сопрограмму
        /// </summary>
        static internal Coroutine CurrProc = null;

        /// <summary>
        /// Текущая исполняемая имитация
        /// </summary>
        static internal SimProc CurrSim = null;

        /// <summary>
        /// Глобальный диспетчер, управляющий работой сопрограмм
        /// </summary>
        static internal Dispatcher Dispatch;

        /// <summary>
        /// Возобновляет приостановленное исполнение сопрограмм под управлением глобального диспетчера.
        /// <para>Если глобального диспетчера нет, порождается исключение</para>
        /// </summary>
        static public void ResumeDispatcher()
        {
            if (Dispatch != null)
            {
                Dispatch.Resume();
            }
            else
                throw new ESimulationException("ResumeDispatcher(): попытка возобновления несуществующего диспетчера сопрограмм");
        }

        /// <summary>
        /// Создает глобальный диспетчер, если его нет, и запускает исполнение сопрограмм под его управлением
        /// <para>Если глобальный диспетчер существует, запускает исполнение сопрограмм под его управлением</para>
        /// </summary>
        /// <param name="first">Сопрограмма, с которой начинается исполнение</param>
        static public void RunDispatcher(Coroutine first)
        {
            if (Dispatch == null)
            {
                Dispatch = new Dispatcher(first);
            }
            else
            {
                Dispatch.NextProc = first;
            }
            Dispatch.Resume(); 
        }

        /// <summary>
        /// Возвращает текущее имитационное время, соответствующее активной исполняемой имитации
        /// </summary>
        /// <returns>Текущее имитационное время</returns>
        static public double SimTime()
        {
            if (CurrSim == null)
                return 0;
            else
                return CurrSim.SimTime();
        }
    }

    /// <summary>
    /// Класс EventNotice - ячейка календаря событий
    /// </summary>
    public abstract class EventNotice : Link
    {
        /// <summary>
        /// Конструктор. Записывает значения параметров в поля объекта
        /// </summary>
        /// <param name="time">Время наступления события</param>
        protected EventNotice(double time)
        {
            EventTime = time;
        }

        /// <summary>
        /// Имитационное время наступления события
        /// </summary>
        internal double EventTime;

        /// <summary>
        /// Вставка в календарь событий до всех уведомлений с тем же значением времени
        /// </summary>
        /// <param name="l">Календарь событий</param>
        internal void InsertPrior(List l)
        {
            Insert(l, PriorCompFunc);
        }

        /// <summary>
        /// Функция сравнения для вставки с приоритетом уведомления о событиях в календарь
        /// </summary>
        /// <param name="a">Ссылка на вставляемое уведомление</param>
        /// <param name="b">Ссылка на очередное уведомление в списке</param>
        /// <returns>true, если ячейка a может быть вставлена перед ячейкой b</returns>
        private static bool PriorCompFunc(ILink a, ILink b)
        {
            return (a as EventNotice).EventTime <= (b as EventNotice).EventTime;
        }

        /// <summary>
        /// Обработка очередного события
        /// </summary>
        public abstract object RunEvent();

        /// <summary>
        /// Изменение времени наступления события и перестановка уведомления в календаре
        /// после всех уведомлений с равным временем наступления события
        /// </summary>
        /// <param name="newTime">Новое время наступления события</param>
        internal void SetTime(double newTime)
        {
            List lst = GetHeader();
            EventTime = newTime;
            Insert(lst);
        }

        /// <summary>
        /// Изменение времени наступления события и перестановка уведомления в календаре
        /// до всех уведомлений с равным временем наступления события
        /// </summary>
        /// <param name="newTime">Новое время наступления события</param>
        internal void SetTimePrior(double newTime)
        {
            List lst = GetHeader();
            EventTime = newTime;
            InsertPrior(lst);
        }
    }

    /// <summary>
    /// Класс ESimulationException - класс исключения имитации
    /// </summary>
    public class ESimulationException : Exception
    {
        /// <summary>
        /// Конструктор со строковым параметром
        /// </summary>
        /// <param name="message">Параметр - сообщение о причине исключения</param>
        public ESimulationException(string message)
            : base(message)
        {
        }
    }

    /// <summary>
    /// Интерфейс IActivatable является базовым для классов объектов, которые могут быть
    /// запланированы в календаре (процессы, событийные объекты)
    /// </summary>
    public interface IActivatable
    {
        /// <summary>
        /// Помещает запись уведомления об активации процесса непосредственно после текущего.
        /// <para>Если процесс находится в активном или приостановленном состоянии, ничего не делает</para>
        /// </summary>
        void Activate();

        /// <summary>
        /// Создает запись уведомления об активации процесса непосредственно после записи указанного процесса
        /// <para>Если процесс находится в активном или приостановленном состоянии, ничего не делает</para>
        /// <para>Если процесс-параметр находится в пассивном или завершенном состоянии, порождается исключение</para>
        /// </summary>
        /// <param name="act">Процесс, после которого следует активировать данный</param>
        void ActivateAfter(ISchedulable act);

        /// <summary>
        /// Создает запись уведомления об активации процесса в указанное время
        /// <para>Если процесс находится в активном или приостановленном состоянии, ничего не делает</para>
        /// </summary>
        /// <param name="t">Имитационное время активации процесса</param>
        void ActivateAt(double t);

        /// <summary>
        /// Создает запись уведомления об активации процесса непосредственно перед записью указанного процесса
        /// <para>Если процесс находится в активном или приостановленном состоянии, ничего не делает</para>
        /// <para>Если процесс-параметр находится в пассивном или завершенном состоянии, порождается исключение</para>
        /// </summary>
        /// <param name="act">Процесс, перед которым следует активировать данный</param>
        void ActivateBefore(ISchedulable act);

        /// <summary>
        /// Создает запись уведомления об активации процесса с указанной задержкой времени
        /// <para>Если процесс находится в активном или приостановленном состоянии, ничего не делает</para>
        /// </summary>
        /// <param name="dt">Задержка относительно текущего имитационного времени</param>
        void ActivateDelay(double dt);

        /// <summary>
        /// Создает запись уведомления об активации процесса в указанное время с приоритетом по отношению к процессам,
        /// запланированным ранее на то же время
        /// <para>Если процесс находится в активном или приостановленном состоянии, ничего не делает</para>
        /// </summary>
        /// <param name="t">Имитационное время активации процесса</param>
        void ActivatePriorAt(double t);

        /// <summary>
        /// Создает запись уведомления об активации процесса с указанной задержкой времени с приоритетом по отношению к процессам,
        /// запланированным ранее на то же время
        /// <para>Если процесс находится в активном или приостановленном состоянии, ничего не делает</para>
        /// </summary>
        /// <param name="dt">Задержка относительно текущего имитационного времени</param>
        void ActivatePriorDelay(double dt);
    }

    /// <summary>
    /// Интерфейс ISchedulable является базовым для классов объектов, для которых возможны манипуляции
    ///  с уведомлениями о событиях (удаление, перемещение и т. п.). Производный от IActivatable
    /// </summary>
    public interface ISchedulable : IActivatable
    {
        /// <summary>
        /// Указывает, находится ли процесс в пассивном или завершенном состоянии
        /// </summary>
        bool Idle
        {
            get;
        }

        /// <summary>
        /// Уведомление о событии, связанное с процессом
        /// </summary>
        EventNotice Event
        {
            get;
        }

        /// <summary>
        /// Переводит процесс в пассивное состояние, удаляя его запись уведомления о событии из календаря
        /// <para>Если процесс является текущим, управление передается следующему по порядку процессу</para>
        /// </summary>
        void Passivate();

        /// <summary>
        /// Перемещает запись уведомления об активации процесса, в том числе приостановленного, непосредственно после текущего.
        /// <para>Если процесс находится в активном состоянии (то есть, является текущим), ничего не делает</para>
        /// </summary>
        void Reactivate();

        /// <summary>
        /// Перемещает запись уведомления об активации процесса непосредственно после записи указанного процесса
        /// <para>Если процесс находится в пассивном состоянии, создает новую запись уведомления</para>
        /// <para>Если процесс является активным, он приостанавливается</para>
        /// <para>Если процесс-параметр находится в пассивном состоянии, порождается исключение</para>
        /// </summary>
        /// <param name="act">Процесс, перед которым следует активировать данный</param>
        void ReactivateAfter(ISchedulable act);

        /// <summary>
        /// Перемещает запись уведомления об активации процесса непосредственно перед записью указанного процесса
        /// <para>Если процесс находится в пассивном состоянии, создает новую запись уведомления</para>
        /// <para>Если процесс является активным, он приостанавливается</para>
        /// <para>Если процесс-параметр находится в пассивном состоянии, порождается исключение</para>
        /// </summary>
        /// <param name="act">Процесс, перед которым следует активировать данный</param>
        void ReactivateBefore(ISchedulable act);

        /// <summary>
        /// Перемещает запись уведомления об активации процесса на указанное время
        /// <para>Если процесс находится в пассивном состоянии, создает новую запись уведомления</para>
        /// <para>Если процесс является активным, он приостанавливается</para>
        /// </summary>
        /// <param name="t">Имитационное время активации процесса</param>
        void ReactivateAt(double t);

        /// <summary>
        /// Перемещает запись уведомления об активации процесса непосредственно перед записью указанного процесса
        /// <para>Если процесс находится в пассивном состоянии, создает новую запись уведомления</para>
        /// <para>Если процесс является активным, он приостанавливается</para>
        /// <para>Если процесс-параметр находится в пассивном состоянии, порождается исключение</para>
        /// </summary>
        /// <param name="dt">Процесс, перед которым следует активировать данный</param>
        void ReactivateDelay(double dt);

        /// <summary>
        /// Перемещает запись уведомления об активации процесса на указанное время с приоритетом.
        /// <para>Если процесс находится в пассивном состоянии, создает новую запись уведомления</para>
        /// <para>Если процесс является активным, он приостанавливается</para>
        /// </summary>
        /// <param name="t">Имитационное время активации процесса</param>
        void ReactivatePriorAt(double t);

        /// <summary>
        /// Перемещает запись уведомления об активации процесса с указанной задержкой времени относительно текущего процесса с приоритетом.
        /// <para>Если процесс находится в пассивном состоянии, создает новую запись уведомления</para>
        /// <para>Если процесс является активным, он приостанавливается</para>
        /// </summary>
        /// <param name="dt">Имитационное время активации процесса</param>
        void ReactivatePriorDelay(double dt);

        /// <summary>
        /// Постановка процесса в очередь и переаод его в режим ожидания
        /// </summary>
        /// <param name="l">Очередь ожидания</param>
        void Wait(List l);
    }
}
