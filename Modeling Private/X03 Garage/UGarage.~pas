unit UGarage;

interface
uses USimulation;

// Моделирование станции технического обслуживания автомобилей

type
  // Класс TCar - обслуживаемый автомобиль
  TCar = class(TProcess)
  protected
    procedure RunProcess; override;
  public
    WaitingStart : Double;
    CarNum : Integer;
    constructor Create;
  end;

  // Класс TBrigade - обслуживающая бригада
  TBrigade = class(TProcess)
  protected
    procedure RunProcess; override;
  public
    constructor Create;
  end;

  // Класс TGarage - процесс симуляции
  TGarage = class(TSimulation)
  protected
    procedure Init; override;
    procedure RunSimulation; override;
  public
    Brigade : TBrigade;
    Parking : TList;
    NotServiced : TList;
    BrigadeStat : TServiceStatistics;
    constructor Create;
    destructor Destroy; override;
  end;

var
  ModelingTime,            // Время моделирования
  MeanServiceTime,         // Среднее время обслуживания
  DeviationServiceTime,    // Стандартное отклонение времени обслуживания
  CarsPerTimeUnit          // Интенсивность потока прибывающих автомобилей
//  MeanWaitTime,            // Среднее время ожидания
//  TotalWaitTime,           // Полное время ожидания
//  BrigadeUsage : Double;   // СТепень загруженности биргады
  : Double;
  CarCount,                // Счетчик автомобилей
//  ServicedCarCount,        // Счетчик обслуженных автомобилей
  ParkingPlaces,           // Число мест на стоянке
//  BusyParkingPlaces,       // Число занятых мест на стоянка
  NoWaitCount : Integer;   // Число автомобилей, обслуженных без ожидания

  // Генераторы случайных чисел
  rndCar,                  // Для интервала прибытия
  rndService : TRandom;    // ДЛя времени обслуживания   

implementation

{ TCar }

constructor TCar.Create;
begin
  inherited;
end;

procedure TCar.RunProcess;
var
  par : TGarage;
begin
  par := Parent as TGarage;
  // ДОбавлен новый автомобиль
  Inc(CarCount);
  CarNum := CarCount;

  // Если на стоянке есть места
  if par.Parking.Size < ParkingPlaces then
  begin
    // Встать в очередь на обслуживание
    InsertLast(par.Parking);

    WaitingStart := SimTime;

    // Активировать бригаду
    ActivateAfter(par.Brigade, Self);
  end
  else
    // Встать в список необслуженных
    InsertLast(par.NotServiced);

  // Запланировать прибытие следующего автомобиля
  ActivateDelay(TCar.Create, rndCar.NegExp(CarsPerTimeUnit));
end;

{ TBrigade }

constructor TBrigade.Create;
begin
  inherited;
end;

procedure TBrigade.RunProcess;
var
  WorkStart, Waited : Double;
  Client : TCar;
  par : TGarage;
begin
  par := Parent as TGarage;
  StopRunning;
  while True do
  begin
    // Удалить все необслуженные (если есть)
    par.NotServiced.Clear;

    // Если стоянка пуста
    while par.Parking.Empty do
      // Ожидать прибытия автомобиля
      Passivate;

    // Запомнить время начала работы
    par.BrigadeStat.Start(SimTime);

    // Извлечь из очереди первого клиента
    Client := (Parent as TGarage).Parking.First as TCar;

    // Время ожидания клиента до начала обслуживания
    Waited := SimTime - Client.WaitingStart;
    Client.Free;

    // Если не ждал
    if Waited = 0 then
      // Увеличить счетчик не ожидавших
      Inc(NoWaitCount);

    // Обслуживание
    Hold(rndService.Normal(MeanServiceTime, DeviationServiceTime));

    // Посчитать время обслуживания
    par.BrigadeStat.Finish(SimTime);
  end;
end;

{ TGarage }

constructor TGarage.Create;
begin
  inherited;
end;

destructor TGarage.Destroy;
begin
  Brigade.Free;
  BrigadeStat.Free;
  Parking.Free;
  NotServiced.Free;
  inherited;
end;

procedure TGarage.Init;
begin
  inherited;
  Brigade := TBrigade.Create;
  Parking := TList.Create(SimTime);
  NotServiced := TList.Create;
  BrigadeStat := TServiceStatistics.Create(1, 0, 0);
//  BusyParkingPlaces := 0;
  CarCount := 0;
//  ServicedCarCount := 0;
  NoWaitCount := 0;
//  TotalWaitTime := 0;
end;

procedure TGarage.RunSimulation;
begin
  // Поставить первый автомобиль в очередь
  Activate(TCar.Create);

  // Задержка на время моделирования
  Hold(ModelingTime);
  // Корректировка статистики
  BrigadeStat.StopStat(SimTime);
  Parking.LengthStat.StopStat(SimTime);

  Detach;
end;

end.
